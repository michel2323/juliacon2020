% DO NOT COMPILE THIS FILE DIRECTLY!
% This is included by the other .tex files.
\begin{frame}
  \frametitle{Upcoming Supercomputers}
    \begin{center}
      \includegraphics[width=.25\textwidth]{./figures/ecp} \\
      % \includegraphics[width=.75\textwidth]{./figures/go} 
    \end{center}
  \begin{columns}[T]
    \begin{column}{0.49\textwidth}
      \begin{center}
        {\bf Aurora}\\
        \includegraphics[width=0.75\textwidth]{./figures/aurora}
      \end{center}
    \end{column}
    \begin{column}{0.49\textwidth}
      \begin{center}
        {\bf Frontier}\\
        \includegraphics[width=0.75\textwidth]{./figures/frontier}
      \end{center}
    \end{column}
  \end{columns}
  \begin{columns}[T]
    \begin{column}{0.49\textwidth}
    \begin{itemize}
      \item Intelâ€™s Xe compute architecture.
      \item $>$ 1 exaflops
    \end{itemize}
    \end{column}
    \begin{column}{0.49\textwidth}
      \begin{itemize}
        \item AMD EPYC processors and Radeon Instinct GPU
        \item 1.5 exaflops
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Power System}
  \begin{columns}
    \begin{column}{0.45\textwidth}
      \includegraphics[width=\textwidth]{figures/slides.png}
    \end{column}
    \begin{column}{0.45\textwidth}
      \begin{center}
        % \includegraphics[width=0.8\textwidth]{figures/DampedSine.png}
      \end{center}
      \begin{itemize}
        \item Protect against contingency scenarios
        \item Demand is uncertain
        \item Generation is uncertain (solar, wind, water)
        \item Recent developments in renewable energies lead to less mass in generators decreasing inertia
        \item Less inertia worsens effects of uncertainty
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Complex Networks}
  \includegraphics[width=\textwidth]{figures/complexn}
  \begin{itemize}
    \item Examples: traffic, Internet, pipelines, power grid
    \item Connection pattern is irregular but not random
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{NLP: Alternate Current Optimal Power Flow}
  \begin{itemize}
    \item {\bf Objective}
    \begin{itemize}
      \item Generation $P_g$ and its cost $c$ at generators $g_i$:
      $ \minimize \sum^G_{i=1} c_i(P_{g_i})$, where $c_i$ is the cost of generator $g_i$
    \end{itemize}
    \item {\bf Constraints}
    \begin{itemize}
      \item Kirchhoff's law: What flows in must flow out (nonlinear, non-convex in ACOPF)
      \begin{align*}
        V_k e^{-j\theta_k} & \sum^{N}_{m=0} (G_{km} + jB_{km})V_m e^{j\theta_m} = P_k - j Q_k,\ k = 1, \dots, N \\
        \text{where}\\
        V_k &\text{ voltage magnitude at node } k\\
        \theta &\text{ voltage angle at node } k\\
        G_{km} + jB_{km}& \text{ element of nodal admittance matrix}\\
        P_k , Q_k &\text{ net real and reactive power entering and leaving node } k
      \end{align*}
      \item Line limits defined through voltage angles $\theta$ at the buses $m$ and $n$:
      $$ \theta^{min}_{nm} \leq \theta_n - \theta_m \leq \theta^{max}_{nm}$$
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Use Interior-Point for NLP}
  {\bf Solve}
  \begin{align*}
  &\minimize f(x)\\ 
  \text{with}&\\
  &g(x) = 0, \ j=1,\dots, l \\
  &h(x) \geq 0, \ i=1,\dots, m \\
  \end{align*}
  {\bf using Newton and barrier functions}
  \begin{align*}
  &\minimize \phi_\mu := f(x) - \mu \sum^m_{i=1} \ln h(x)\\ 
  \text{with}&\\
  &g(x) = 0, \ j=1,\dots, l 
  \end{align*}
  \begin{itemize}
    \item Barrier functions exacerbate ill-conditioning
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Reduced Method}
\begin{columns}
\begin{column}{0.7\linewidth}
  
  State $\bm{x}$, control $\bm{u}$, and function $h: \REAL^{n} \times \REAL^{m} \to \REAL^{p}$
  \begin{equation*}\label{eq:globalproblem}
    \begin{array}{r@{\;\;}l}
      \min_{\bm{x}, \bm{u}} & f(\bm{x}, \bm{u}) \\
      \text{s.t.} & \alert{g(\bm{x}, \bm{u}) = 0 }\\
                  & h(\bm{x}, \bm{u}) \leq 0 \;,
                  \quad \underline{u} \leq \bm{u} \leq \overline{u}  \;.
    \end{array}
  \end{equation*}
  Augmented Lagrangian $\mathcal{L}$:
  \begin{equation*}
    \mathcal{L}(\bm{x}, \bm{u}, \lambda) = f(\bm{x}, \bm{u}) + \lambda^\top g(\bm{x}, \bm{u}) \; ,
  \end{equation*}
  Solver for multipliers $\lambda$:
  \begin{equation*}
    \alert{\dpart{g}{x}^\top} \lambda = -\dpart{f}{x}  \; .
  \end{equation*}
  Reduced gradient:
  \begin{equation*}
    \grad{f}{u} = \dpart{f}{u} + \dpart{g}{u}^\top\lambda \; .
  \end{equation*}
\end{column}
\end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interior-Point and GPUs}
  {\bf Current State}
  \begin{itemize}
    \item De facto standard solver: Ipopt
    \item Very ill-conditioned system (up $1e^{16}$)
    \item Requires indefinite sparse direct inertia revealing solver
    \item Ipopt only supports direct solver (exception: Pardiso)
    \item default MUMPS, preferred are HSL libary MA27, MA57 
    \item PIPS-NLP \footnote{\cite{pips}} \footnote{https://github.com/Argonne-National-Laboratory/PIPS} implements Schur complement for two-stage optimization
    \item HiOp\footnote{https://github.com/LLNL/hiop} mixed dense-sparse solver 
  \end{itemize}
\end{frame}
\begin{frame}
  \frametitle{Distributed Parallel Interior-Point Solvers}
  \begin{center}
    \includegraphics[width=0.65\textwidth]{figures/twostageopt}
  \end{center}
  \begin{columns}[T]
    \begin{column}{0.45\textwidth}
      {\bf PIPS-NLP}
      \begin{itemize}
        \item Model in \lstinline{JuMP.jl}
        \item Sparse algebra in PIPS
        \item Scalar variables
      \end{itemize}
    \end{column}
    \begin{column}{0.45\textwidth}
      {\bf HiOp}
      \begin{itemize}
        \item Mixed-dense sparse interface for subproblems
        \item Vector objects
      \end{itemize}
    \end{column}
  \end{columns}
  \begin{itemize}
    \item Schur complement decomposition for two-stage scenario based optimization
    \item In this talk: \alert{Domain decomposition for a single optimal power flow scenario}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Implementation}
  {\bf Goals}
  \begin{itemize}
    \item Compute Jacobian using automatic differentiation
    \item Implement a preconditioner
    \item Implement a Krylov method
    \item No computation on the host in main loop, no data transfer
    \item All in Julia, no external calls if possible
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{}
  \centering
  {\Huge Automatic Differentiation}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Derivatives}
  {\bf Newton-Raphson}
  \begin{minipage}{0.8\textwidth}
    \begin{lstlisting}
    go = true
    while(go)
      dx .= jacobian(x)\f(x)
      x  .= x .- dx
      go = norm(f(x)) < tol ? true : false
    end
    \end{lstlisting}
   \end{minipage}
  {\bf Automatic Differentiation}
  \begin{itemize}
    \item \lstinline{F = f(x)} $\rightarrow$ \alert{\lstinline{J = jacobian(x)}}\footnote{\cite{RevelsLubinPapamarkou2016}}
    \item Two modes: \Colorbox{green}{Adjoint} or \Colorbox{red}{tangent}
    \item \Colorbox{green}{\lstinline{adj(x, y) = (J(x))'*y)}}, \Colorbox{red}{\lstinline{tgt(x,d) = J(x)*d}} 
    \item \Colorbox{green}{\lstinline{size(x) >> size(F)}} or \Colorbox{red}{\lstinline{size(x) <= size(F)}}
    \item number of buses $\propto$ \lstinline{size(x) = size(F)}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Jacobian Coloring}
    \begin{figure}
\centering
     \begin{subfigure}[b]{0.35\linewidth}
         \centering
         \includegraphics[height=\textwidth]{figures/sparse_coloring.PNG}
         \caption{Colored Jacobian: A valid coloring has no color appearing twice in a row}
     \end{subfigure}
     \hspace{0.05\linewidth}
     \begin{subfigure}[b]{0.35\linewidth}
         \centering
         \includegraphics[height=\linewidth]{figures/compressed_coloring.PNG}
         \caption{Compressed Jacobian in dense storage: White color entries are unused space}
     \end{subfigure}
    \caption{Jacobian coloring on the IEEE 30 bus case} %bus case compressing the matrix from $53 \times 53$ to $15 \times 53$}
    \label{fig:coloring}
\end{figure}
  \begin{itemize}
    \item Using greedy algorithm in \lstinline{SparseDiffTools.jl}
    % \item To get full Jacobian, one has to do $c$ times \lstinline{tgt(x,d) = J(x)*d}
    \item Complexity for Jacobian goes from $\bigo{n} \times cost(f)$ to $\bigo{c} \times cost(f)$
  \end{itemize}
\end{frame}

% \begin{frame}
%   \frametitle{AD on GPUs in Julia}
%   \begin{center}
%       \includegraphics[width=0.75\textwidth]{figures/F}
%   \end{center}
% \end{frame}
\begin{frame}
  \frametitle{AD on GPUs in Julia}
  \begin{center}
    \lstinline{F = T(undef, n)}
  \end{center}
  \begin{itemize}
    \item Float vector: \lstinline{T = Vector\{Float64\}}
    \item Arbitrary precision vector: \lstinline{T = Vector\{BigFloat\}}
    \item First-order tangent: \lstinline{t1s\{N\} =  ForwardDiff.Dual\{Nothing,Float64, N\} where N}
    \item Second-order tangent: \lstinline{t2s\{M,N\} =  ForwardDiff.Dual\{Nothing,t1s\{N\}, M\} where M, N}
    \item First-order tangent vector: \lstinline{T = Vector\{t1s\{N\}\}}
    \item First-order tangent GPU vector: \lstinline{T = CuVector\{t1s\{N\}\}}
    \item Relying on \lstinline{CUDA.jl} \footnote{\cite{besard2018juliagpu}} \footnote{\cite{besard2019prototyping}}
    \item \alert{broadcast operator \lstinline{x .= a .* b}}
  \end{itemize}
\end{frame}

% \begin{frame}
%   \frametitle{AD on GPUs in Julia}
%   \begin{columns}[T]
%     \begin{column}{0.35\textwidth}
%       \begin{center}
%         \vspace{0.2cm}
%         \includegraphics[width=\linewidth]{figures/compression}
%       \end{center}
%     \end{column}
%     \begin{column}{0.6\textwidth}
%       \begin{center}
%         \includegraphics[width=\linewidth]{figures/simd}
%       \end{center}
%     \end{column}
%   \end{columns}
%   \begin{center}
%   \end{center}
%   {\bf SIMD over sparsity colors}
%   \begin{itemize}
%     \item Change from \lstinline{F = f(x)} to \lstinline{J = f(x)} on GPUs is a type change from \lstinline{Vector\{Float64\}} to \lstinline{CuVector\{t1s\{c\}\}}
%   \end{itemize}
% \end{frame}

\begin{frame}
  \frametitle{}
  \centering
  {\Huge Preconditioner}
\end{frame}

\begin{frame}
  \frametitle{Linear Solver}
  {\bf Tour de Solvers, solver we have experience with}
  \begin{table}
  \begin{tabular}{p{5cm}|lll}
    MA27, MA57, MUMPS, SPQR, CUSOLVER, SPRAL SSIDS, SuperLU & indefinite & sparse & direct \\
    \hline
    BLAS, CUBLAS & indefinite & dense  & direct \\
    \hline
    CHOLMOD, SPRAL SSIDS& positive definite & sparse & direct \\
    \hline
    \lstinline{IterativeSolvers.jl}, \lstinline{Krylov.jl}, PETSc & indefinite & sparse & iterative \\ 
  \end{tabular}
\end{table}
  \begin{itemize}
    \item For IPM: indefinite direct sparse intertia (LDL) revealing linear solver
    \item Krylov methods are tricky with IPM 
    \item Direct solvers are tricky with GPUs
    \item Reduced space $\rightarrow$ try Krylov methods, system still indefinite, no inertia needed
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Linear solver}
    \begin{figure}
      \includegraphics[width=0.75\textwidth]{figures/gmresbicgstab}
    \end{figure}
  \begin{itemize}
    \item Best for GPUs: Iterative solver
    \item GMRES and BiCGSTAB \footnote{\cite{sleijpen1993bicgstab}} in \lstinline{IterativeSolvers.jl}, no GPU support 
    \item GMRES in \lstinline{Krylov.jl}, but it had no BiCGSTAB 
    \item Wrote a naive implementation of BiCGSTAB \footnote{\cite{bicgstabVorst}}
    \item A. Montoison implemented a GPU enabled BiCGSTAB in \lstinline{Krylov.jl}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Preconditioner}
  {\bf Setup}
  \begin{itemize}
    \item Create a partitioning (METIS)
  \end{itemize}
  {\bf Update P}
  \begin{tabular}{m{0.15\textwidth}m{0.05\textwidth}m{0.3\textwidth}m{0.05\textwidth}m{0.3\textwidth}}
        \includegraphics[width=0.09\textwidth]{./figures/compressed_coloring.PNG}
    &
    {\Huge $\rightarrow$}
    &
        \includegraphics[width=0.3\textwidth]{figures/gpublocks}
    &
    {\Huge $\rightarrow$}
    &
        \includegraphics[width=0.3\textwidth]{./figures/csr}
    \\
  \end{tabular}
    \begin{enumerate}
      \item Read dense compressed Jacobian into dense Jacobi blocks
      \item Batch inversion of dense blocks using CUBLAS
      \item Update sparse matrix P from dense Jacobi blocks
    \end{enumerate}
  {\bf Code size}
  \begin{itemize}
    \item 200 lines of code for BOTH CPU and GPU implementation
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Preconditioner}
\begin{figure}
  \centering
  \fbox{
    \begin{tikzpicture}[scale=2]
    \foreach \i in {0,...,\nrows}{
      \foreach \j in {0,...,\ncols}{
      \pgfplotstablegetelem{\i}{\j}\of\matrixJ
      \ifnum\pgfplotsretval=0
        \relax
      \fi
      \ifnum\pgfplotsretval=1
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=blue] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=2
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=yellow] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=3
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=orange] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=4
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=green] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=5
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=pink] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=6
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=red] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=7
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=purple] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=8
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=brown] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=9
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=magenta] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=10
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=gray] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=11
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=black] at (\j pt,-\i pt) {};
      \fi
      };
    };
    \end{tikzpicture}
  }
  %
  \fbox{
    \begin{tikzpicture}[scale=2]
    \foreach \i in {0,...,\nrows}{
      \foreach \j in {0,...,\ncols}{
      \pgfplotstablegetelem{\i}{\j}\of\matrixN
      \ifnum\pgfplotsretval=0
        \relax
      \fi
      \ifnum\pgfplotsretval=1
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=blue] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=2
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=yellow] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=3
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=orange] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=4
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=green] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=5
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=pink] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=6
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=red] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=7
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=purple] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=8
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=brown] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=9
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=magenta] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=10
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=gray] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=11
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=black] at (\j pt,-\i pt) {};
      \fi
      };
    };
    \end{tikzpicture}
  }
  \caption{Jacobian partitioning on the IEEE-30 bus case. The figures show the Jacobian with 10 partitions (left) and the Jacobian rearranged by cluster (right). Coefficients with identical color mean that the associated rows and columns share the same partition.}
  \label{fig:spyJ}
\end{figure}
\end{frame}

\begin{frame}
  \frametitle{Preconditioner}
\begin{figure}
  \centering
  \fbox{
    \begin{tikzpicture}[scale=2]
    \foreach \i in {0,...,\nrows}{
      \foreach \j in {0,...,\ncols}{
      \pgfplotstablegetelem{\i}{\j}\of\matrixP
      \ifnum\pgfplotsretval=0
        \relax
      \fi
      \ifnum\pgfplotsretval=1
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=blue] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=2
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=yellow] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=3
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=orange] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=4
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=green] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=5
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=pink] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=6
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=red] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=7
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=purple] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=8
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=brown] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=9
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=magenta] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=10
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=gray] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=11
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=black] at (\j pt,-\i pt) {};
      \fi
      };
    };
    \end{tikzpicture}
  }
  %
  \fbox{
    \begin{tikzpicture}[scale=2]
    \foreach \i in {0,...,\nrows}{
      \foreach \j in {0,...,\ncols}{
      \pgfplotstablegetelem{\i}{\j}\of\matrixM
      \ifnum\pgfplotsretval=0
        \relax
      \fi
      \ifnum\pgfplotsretval=1
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=blue] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=2
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=yellow] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=3
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=orange] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=4
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=green] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=5
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=pink] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=6
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=red] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=7
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=purple] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=8
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=brown] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=9
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=magenta] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=10
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=gray] at (\j pt,-\i pt) {};
      \fi
      \ifnum\pgfplotsretval=11
        \node[rectangle, minimum size=1pt, inner sep=0pt, fill=black] at (\j pt,-\i pt) {};
      \fi
      };
    };
    \end{tikzpicture}
  }
  \caption{The figures show the block-Jacobi preconditioner computed using batch inversion on diagonal blocks of the restructured Jacobian (right) and the rearranged one that will be used for $\bm{P}_i\,*\,\bm{v}$ products (left).}
  \label{fig:spyP}
\end{figure}
\end{frame}

\begin{frame}
  \frametitle{}
  \centering
  {\Huge Results}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ExaPF.jl}
  \begin{lstlisting}
    pkg> add ExaPF
  \end{lstlisting}
  \begin{itemize}
    \item \url{https://exanauts.github.io/}
    \item Julia for Summit builds
    \item Other research software
    \item \url{https://github.com/exanauts/ExaPF.jl}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{ExaPF.jl}
  {\bf Example: 30,000 bus system}
  \begin{lstlisting}
    julia> datafile = "GO-Data/.../Network_30R-025/.../case.raw"
    julia> sol, conv, res = pf(datafile, 1000, "bicgstab", CUDADevice())
  \end{lstlisting}
  \begin{itemize}
    \item \lstinline{size(J)} = 57,721 $\times$ 57,721 
    \item Block Jacobi size: 59 $\times$ 59 $\approx$ 25 MB
    \item Total GPU memory usage: 5 GB
    \item Number of Jacobian colors: 29
    \item 4 Newton iterations with $tol = 1e^{-6}$, total BiCGSTAB iterations: 3,752 
    \item Code runs on local workstation {\it moonshot (x64)} and Summit (PPC) both equipped with NVIDIA Quadro GV100 based on Volta 
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Results}
  \begin{figure}
\begin{tikzpicture}[scale=0.8]
\begin{axis}[
    ybar,
    enlargelimits=0.15,
    legend style={at={(0.5,-0.15)},
      anchor=north,legend columns=-1},
    ylabel={Total runtime (s)},
    cycle list name=cbww,
    symbolic x coords={IEEE300,PEGASE,GO1,GO2},
    xtick=data,
    ymajorgrids,
    % nodes near coords,
    % nodes near coords align={vertical},
    ]
\addplot coordinates {(IEEE300,0.00673) (PEGASE,0.432) (GO1,0.328) (GO2,0.760)};
\addplot coordinates {(IEEE300,0.0915) (PEGASE,2.238) (GO1,0.643) (GO2,1.797)};
\addplot coordinates {(IEEE300,0.035) (PEGASE,1.480) (GO1,3.299) (GO2,10.338)};
\legend{\strut UMFPACK \quad,\strut \BiCGSTAB \quad,\strut CUSOLVE}
\end{axis}
\end{tikzpicture}
\caption{Total runtime with various linear solvers}
\label{fig:totalruntime}
\end{figure}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Results}
\begin{figure}
\begin{tikzpicture}[scale=0.80]
\begin{axis}[
    ybar stacked,
	bar width=15pt,
% 	nodes near coords,
    enlargelimits=0.15,
    cycle list name=cbww,
    legend style={at={(0.5,-0.20)},
      anchor=north,legend columns=-1},
    ylabel={Fraction of total runtime},
    symbolic x coords={IEEE300, PEGASE, GO1, GO2},
    xtick=data,
    ymin = 0,
    ymajorgrids,
    x tick label style={rotate=45,anchor=east},
    ]
\addplot+[ybar] plot coordinates {(IEEE300,0.056) (PEGASE,0.045) 
  (GO1,0.0321) (GO2,0.01714)};
\addplot+[ybar] plot coordinates {(IEEE300,0.107) (PEGASE,0.087)
  (GO1,0.1742) (GO2,0.2009)}; 
\addplot+[ybar] plot coordinates {(IEEE300,0.82) (PEGASE,0.85) 
  (GO1,0.792) (GO2,0.7807)}; 
\legend{\strut AutoDiff \quad, \strut PC \quad, \strut \BiCGSTAB}
\end{axis}
\end{tikzpicture}
\caption{Fraction of runtime for the three most costly computations: \BiCGSTAB, preconditioner (PC), and Jacobian computation through AutoDiff. The bulk of the time is spent in \BiCGSTAB performing matrix-vector products.}
\label{fig:relperformance}
\end{figure}
\end{frame}


\begin{frame}
  \frametitle{Conclusions and Outlook}
  {\bf Optimization on GPUs for NLPs}
  \begin{itemize}
    \item ExaPF.jl in reduced gradient method for OPF
    \item Second-order optimization 
    \begin{itemize}
      \item Requires solving a system with multiple RHS
      \item Multiple RHS BiCGSTAB has been implemented in \lstinline{Krylov.jl}
      \item Block BiCGSTAB is in the work for \lstinline{Krylov.jl}
    \end{itemize}
    \item Preconditioners with overlap (e.g. additive Schwarz) on the GPU
    \item ILU, ICC
    \item Good edge weights for the partitioning
    \item Much harder systems for OPF with inequality constraints
    \item Support for GPU Arrays on Intel and AMD GPUs
    \item Augmented Lagrangian with domain decomposition
  \end{itemize}
\end{frame}

\begin{frame}[noframenumbering,plain,allowframebreaks]{References}
    \printbibliography[heading=none]
\end{frame}



